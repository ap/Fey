* Be the parts of Alzabo that I use - namely automating query creation, simple caching

* Cooperate with standard schema definition practice - A SQL file
** Load schema by reverse engineering or define via code
** This is simpler to port to multiple DBMS backends

* Method auto-generation should be completely separate, and not rely
  on complicated subclassing schemes like Alzabo::MethodMaker

* Query creation should be not be a method of schema or tables, rather
  a separate thing
** This makes subselect-type queries, unions, etc, much simpler to
   formulate and use
** Preserve the clever bits of Alzabo's handling of aliases for
   tables/columns, auto-join, auto-alias for functions so they can be
   used in ORDER BY/GROUP BY

* No referential integrity handling - a legacy of starting Alzabo with
  MySQL
** Allows simpler caching
** Allows mass update/insert DML

* Keep potential rows in some form, very handy

Problems with Alzabo

* Adding support for a new DBMS is a lot of work. Too many different
  bits to code up.

* Support for multiple versions of one DBMS is sketchy or
  non-existent. Either old stuff doesn't work, or it defaults to
  supporting old capabilities only (32 char name limit in Pg, for
  example).
** Unfortunately, DBMS's do not provide good support for discovering
   much of this info after a connection.

* GUI design tools exist for specific databases that do a better job
  of catering to the database's quirks/features.

* Separation of Runtime/Create made sense 6 years ago, but probably
  isn't worthwhile nowadays.

----------------------

Packages

* Low-level SQL maker

* Higher-level SQL maker that can do things like make insert SQL for a
  given table/set of columns

* A simple OO-RDBMS mapper like Class::AlzaboWrapper - with caching of
  objects and of object method
